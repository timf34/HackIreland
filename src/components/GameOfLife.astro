---
---
<canvas id="gameOfLife" class="game-of-life"></canvas>

<style>
    .game-of-life {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        opacity: 0.3;
    }
</style>

<script>
    class GameOfLife {
        private canvas: HTMLCanvasElement;
        private ctx: CanvasRenderingContext2D;
        private cellSize: number;
        private cols: number;
        private rows: number;
        private grid: boolean[][];
        private lastUpdate: number;
        private updateInterval: number;

        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            const context = canvas.getContext('2d');
            if (!context) throw new Error('Could not get canvas context');
            this.ctx = context;
            this.cellSize = 50;
            this.cols = 0;
            this.rows = 0;
            this.grid = [];
            this.lastUpdate = 0;
            this.updateInterval = 300; // Update every 200ms (adjust this value to change speed)

            this.resize();
            this.animate = this.animate.bind(this);
            requestAnimationFrame(this.animate);

            window.addEventListener('resize', () => this.resize());
        }

        resize(): void {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.cols = Math.ceil(this.canvas.width / this.cellSize);
            this.rows = Math.ceil(this.canvas.height / this.cellSize);

            this.grid = Array(this.rows).fill(null).map(() =>
                Array(this.cols).fill(null).map(() => Math.random() < 0.1)
            );
        }

        countNeighbors(x: number, y: number): number {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newX = (x + i + this.rows) % this.rows;
                    const newY = (y + j + this.cols) % this.cols;
                    count += this.grid[newX][newY] ? 1 : 0;
                }
            }
            return count;
        }

        update(): void {
            const newGrid = Array(this.rows).fill(null).map(() => Array(this.cols).fill(false));

            for (let x = 0; x < this.rows; x++) {
                for (let y = 0; y < this.cols; y++) {
                    const neighbors = this.countNeighbors(x, y);
                    if (this.grid[x][y]) {
                        newGrid[x][y] = neighbors === 2 || neighbors === 3;
                    } else {
                        newGrid[x][y] = neighbors === 3;
                    }
                }
            }

            this.grid = newGrid;
        }

        draw(): void {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';

            for (let x = 0; x < this.rows; x++) {
                for (let y = 0; y < this.cols; y++) {
                    if (this.grid[x][y]) {
                        this.ctx.fillRect(
                            y * this.cellSize,
                            x * this.cellSize,
                            this.cellSize - 1,
                            this.cellSize - 1
                        );
                    }
                }
            }
        }

        animate(timestamp: number): void {
            // Update the game state at fixed intervals
            if (timestamp - this.lastUpdate >= this.updateInterval) {
                this.update();
                this.lastUpdate = timestamp;
            }

            // Draw every frame for smooth rendering
            this.draw();
            requestAnimationFrame(this.animate);
        }
    }

    // Initialize when the DOM is loaded
    window.addEventListener('load', () => {
        const canvas = document.getElementById('gameOfLife') as HTMLCanvasElement;
        if (canvas) new GameOfLife(canvas);
    });
</script>