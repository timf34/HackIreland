---
---
<canvas id="gameOfLife" class="game-of-life"></canvas>

<style>
    .game-of-life {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        opacity: 0.3; /* Adjust this to make the effect more or less subtle */
    }
</style>

<script>
    class GameOfLife {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.cellSize = 50; // Match grid size
            this.resize();

            // Initialize with random cells
            this.grid = Array(this.rows).fill().map(() =>
                Array(this.cols).fill().map(() => Math.random() < 0.1)
            );

            this.animate = this.animate.bind(this);
            requestAnimationFrame(this.animate);

            // Handle window resize
            window.addEventListener('resize', () => this.resize());
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.cols = Math.ceil(this.canvas.width / this.cellSize);
            this.rows = Math.ceil(this.canvas.height / this.cellSize);

            // Reinitialize grid on resize
            if (!this.grid || this.grid.length !== this.rows) {
                this.grid = Array(this.rows).fill().map(() =>
                    Array(this.cols).fill().map(() => Math.random() < 0.1)
                );
            }
        }

        countNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newX = (x + i + this.rows) % this.rows;
                    const newY = (y + j + this.cols) % this.cols;
                    count += this.grid[newX][newY] ? 1 : 0;
                }
            }
            return count;
        }

        update() {
            const newGrid = Array(this.rows).fill().map(() => Array(this.cols).fill(false));

            for (let x = 0; x < this.rows; x++) {
                for (let y = 0; y < this.cols; y++) {
                    const neighbors = this.countNeighbors(x, y);
                    if (this.grid[x][y]) {
                        newGrid[x][y] = neighbors === 2 || neighbors === 3;
                    } else {
                        newGrid[x][y] = neighbors === 3;
                    }
                }
            }

            this.grid = newGrid;
        }

        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';

            for (let x = 0; x < this.rows; x++) {
                for (let y = 0; y < this.cols; y++) {
                    if (this.grid[x][y]) {
                        this.ctx.fillRect(
                            y * this.cellSize,
                            x * this.cellSize,
                            this.cellSize - 1,
                            this.cellSize - 1
                        );
                    }
                }
            }
        }

        animate() {
            // Slow down the animation
            if (performance.now() % 10 === 0) {
                this.update();
            }
            this.draw();
            requestAnimationFrame(this.animate);
        }
    }

    // Initialize when the DOM is loaded
    window.addEventListener('load', () => {
        const canvas = document.getElementById('gameOfLife');
        new GameOfLife(canvas);
    });
</script>